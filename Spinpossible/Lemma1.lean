import Mathlib.Algebra.Star.Order
import Mathlib.Combinatorics.SimpleGraph.Path
import Mathlib.GroupTheory.Perm.Support

-- HEAVILY inspired by Group.exists_list_of_mem_closure
theorem Subgroup.exists_list_of_mem_closure [Group M] {s : Set M} {a : M} (h : a ∈ Subgroup.closure s) :
    ∃ l : List M, (∀ x ∈ l, x ∈ s ∨ x⁻¹ ∈ s) ∧ l.prod = a := by
  refine Subgroup.closure_induction h
    (fun {x} hxs => ⟨[x], List.forall_mem_singleton.2 <| Or.inl hxs, one_mul _⟩)
    ⟨[], List.forall_mem_nil _, rfl⟩ ?_ ?_
  · intro a b ⟨La, HL1a, HL2a⟩ ⟨L, HL1, HL2⟩
    use La ++ L
    aesop
  · intro a ⟨L, HL1, HL2⟩
    use L.reverse.map Inv.inv
    constructor
    · intro w hw
      have : w⁻¹ ∈ L := by aesop
      have := HL1 _ this
      aesop
    · simp
      have : L.prod⁻¹ = a⁻¹ := by aesop
      rw [←this]
      simp [List.prod_inv_reverse]

open Equiv

lemma foldl_apply_eq_scanl_last {α : Type*}
    (l : List (Perm α)) (x : α)
    : List.foldl (fun a τ ↦ τ a) x l =
    (l.scanl (fun a τ ↦ τ a) x).get ⟨l.length, by simp [List.length_scanl]⟩ := by
  induction' l with head tail ih generalizing x
  · aesop
  · aesop

lemma foldr_apply_eq_prod_x {α : Type*}
    (l : List (Perm α)) (x : α)
    : List.foldr (fun τ a ↦ τ a) x l = l.prod x := by
  induction' l with head tail ih generalizing x
  · simp [List.foldl, List.prod, Perm.mul_def, Equiv.refl_apply]
  · simp_all [List.foldl]

lemma foldl_eq_reverse_prod {α : Type*}
  (l : List (Equiv.Perm α)) (x : α)  :
  (List.foldl (fun a τ ↦ τ a) x l) = l.reverse.prod x := by
  induction l generalizing x with
  | nil => simp
  | cons τ tl ih => simp [List.foldl]; rw [ih]

lemma swap_inv_eq_self [DecidableEq α] {x : Perm α} (h : x.IsSwap) : x = x⁻¹ := by
  have ⟨_, _, _, hswap⟩ := h
  rw [hswap]
  apply swap_inv

lemma graph_connected.aux1 [DecidableEq α]
  (l : List (Equiv.Perm α)) (hl : ∀ τ ∈ l, τ.IsSwap) (h : l.prod = Equiv.swap x y)
  : (List.scanl (fun a τ ↦ τ a) x l).get ⟨l.length, by simp [List.length_scanl]⟩ = y := by
  have h_get : (l.scanl (fun a τ ↦ τ a) x).get ⟨l.length, by simp [List.length_scanl]⟩ =
      l.foldl (fun a τ ↦ τ a) x := by
    simp [foldl_apply_eq_scanl_last]
  rw [h_get]
  have h1 : l.foldl (fun a τ ↦ τ a) x = l.reverse.prod x := by
    apply foldl_eq_reverse_prod l x
  have h_prod_reverse : l.reverse.prod = l.prod⁻¹ := by
    have a1 : ∀ w ∈ l, w⁻¹ = w := by
      intro w hw
      exact swap_inv_eq_self (hl w hw)|>.symm
    simpa [List.map_eq_map_iff.mpr a1, List.map_id] using l.prod_reverse_noncomm
  rw [h1, h_prod_reverse, h]
  simp

open Equiv SimpleGraph Subgroup Equiv.Perm in
lemma graph_connected [DecidableEq α] (E : Set (Equiv.Perm α))
    (hE : ∀ σ ∈ E, σ.IsSwap) (h_closure : Subgroup.closure E = ⊤)
    : (SimpleGraph.fromRel (λ x y => swap x y ∈ E)).Preconnected := by
  let G := SimpleGraph.fromRel (λ x y => swap x y ∈ E)
  -- Define the action of the subgroup generated by E on α
  let H := Subgroup.closure E
  have hH_top : H = ⊤ := h_closure
  have h_transitive : ∀ x y : α, ∃ σ ∈ H, σ x = y := by
    intros x y
    have h_swap : swap x y ∈ H := by
      rw [hH_top]
      exact mem_top _
    exact ⟨swap x y, h_swap, swap_apply_left x y⟩
  intro x y
  have h_swap_in_H : swap x y ∈ H := by
    rw [hH_top]
    exact mem_top _
  -- Express swap x y as a product of elements from E
  have : ∃ l : List (Equiv.Perm α), (∀ τ ∈ l, τ ∈ E) ∧ l.prod = swap x y := by
    have ⟨l, h1, h2⟩ := Subgroup.exists_list_of_mem_closure h_swap_in_H
    use l
    simp_all only [mem_top, true_and, Finset.mem_coe, and_true, H]
    intro τ a
    rcases (h1 _ a) with h | h
    · exact h
    · have : τ⁻¹.IsSwap := hE _ h
      rwa [swap_inv_eq_self this] at h
  obtain ⟨l, hlE, hl_prod⟩ := this
  -- Build the sequence of vertices starting from x by applying the permutations in l
  let vertices := l.scanl (λ a τ => τ a) x
  have : vertices.length = l.length + 1 := l.length_scanl x
  have h_adj : ∀ i (hi : i < l.length),
      G.Adj (vertices.get ⟨i, by omega⟩) (vertices.get ⟨i+1, by omega⟩) ∨ vertices.get ⟨i, by omega⟩ = vertices.get ⟨i+1, by omega⟩ := by
    intros i hi
    by_cases pol : vertices.get ⟨i, by omega⟩ = vertices.get ⟨i+1, by omega⟩
    · right; assumption
    left
    let τ := l.get ⟨i, by omega⟩
    have hτE : τ ∈ E := hlE τ (List.get_mem l i (by omega))
    obtain ⟨a, b, _, hτ_eq⟩ := hE τ hτE
    have h_next : vertices.get ⟨i+1, by omega⟩ = τ (vertices.get ⟨i, by omega⟩) := by
      simp [vertices]
      have hq : i + 1 < (l.scanl (fun a τ ↦ τ a) x).length := by
        simp [vertices] at this
        omega
      exact List.get_succ_scanl (h := hq)
    have h_swap_in_E : swap (vertices.get ⟨i, by omega⟩) (vertices.get ⟨i+1, by omega⟩) ∈ E := by
      rw [h_next, hτ_eq]
      by_cases h_case : vertices.get ⟨i, by omega⟩ = a
      · rw [h_case, swap_apply_left]
        simp_all
      · by_cases h_case' : vertices.get ⟨i, by omega⟩ = b
        · rw [h_case', swap_apply_right, swap_comm]
          simp_all
        · rw [hτ_eq] at h_next
          have := swap_apply_of_ne_of_ne h_case h_case'
          simp_all
    rw [fromRel_adj]
    constructor
    · by_contra yo
      rw [yo] at h_swap_in_E
      have := hE _ h_swap_in_E
      rw [swap_self] at this
      contradiction
    · simp_all
  -- Construct the path from x to y using the sequence of vertices
  let rec build_walk (n : Nat) (hn : n ≤ l.length)
      : G.Walk (vertices.get ⟨n, by omega⟩) (vertices.get ⟨l.length, by omega⟩) :=
    if h_eq : n = l.length then by
      rewrite [Fin.mk.inj_iff.mpr h_eq]
      exact Walk.nil
    else
      let tail := build_walk (n + 1) (by omega)
      if re : vertices.get ⟨n, by omega⟩ = vertices.get ⟨n + 1, by omega⟩ then by
        rewrite [re]
        exact tail
      else
        have := h_adj n (by omega)
        have edge : G.Adj (vertices.get ⟨n, by omega⟩) (vertices.get ⟨n + 1, by omega⟩) := by tauto
        Walk.cons edge tail
  -- Build the walk starting from n = 0
  let walk := build_walk 0 (by omega)
  have h_start : vertices.get ⟨0, by omega⟩ = x := by
    simp [vertices]
  have h_end : vertices.get ⟨l.length, by omega⟩ = y := by
    simp [vertices]
    have := graph_connected.aux1 l (by simp_all) hl_prod
    simp_all
  rw [← h_start, ← h_end]
  exact ⟨walk⟩
