import Mathlib.Combinatorics.SimpleGraph.Path
import Mathlib.GroupTheory.Perm.Sign

-- HEAVILY inspired by Group.exists_list_of_mem_closure
theorem Subgroup.exists_list_of_mem_closure [Group M] {s : Set M} {a : M} (h : a ∈ Subgroup.closure s) :
    ∃ l : List M, (∀ x ∈ l, x ∈ s ∨ x⁻¹ ∈ s) ∧ l.prod = a := by
  refine Subgroup.closure_induction h
    (fun {x} hxs => ⟨[x], List.forall_mem_singleton.2 <| Or.inl hxs, one_mul _⟩)
    ⟨[], List.forall_mem_nil _, rfl⟩ ?_ ?_
  · intro a b ⟨La, HL1a, HL2a⟩ ⟨L, HL1, HL2⟩
    use La ++ L
    aesop
  · intro a ⟨L, HL1, HL2⟩
    use L.reverse.map Inv.inv
    constructor
    · intro w hw
      have : w⁻¹ ∈ L := by aesop
      have := HL1 _ this
      aesop
    · rw [← congr($HL2⁻¹)]
      simp [List.prod_inv_reverse]

open Equiv

lemma foldl_apply_eq_scanl_last {α : Type*}
    (l : List (Perm α)) (x : α)
    : List.foldl (fun a τ ↦ τ a) x l =
    (l.scanl (fun a τ ↦ τ a) x)[l.length]'(by simp [List.length_scanl]) := by
  induction' l with head _ ih generalizing x
  · rfl
  · exact ih _

lemma foldl_eq_reverse_prod {α : Type*}
  (l : List (Equiv.Perm α)) (x : α)  :
  (List.foldl (fun a τ ↦ τ a) x l) = l.reverse.prod x := by
  induction' l generalizing x
  · rfl
  · simp_all [List.foldl]

lemma swap_inv_eq_self [DecidableEq α] {x : Perm α} (h : x.IsSwap) : x = x⁻¹ := by
  have ⟨_, _, _, hswap⟩ := h
  rw [hswap, swap_inv]

lemma graph_connected.aux1 [DecidableEq α]
  {l : List (Equiv.Perm α)} (hl : ∀ τ ∈ l, τ.IsSwap) (h : l.prod = Equiv.swap x y)
  : (List.scanl (fun a τ ↦ τ a) x l)[l.length]'(by simp [List.length_scanl]) = y := by
  have h_prod_reverse : l.reverse.prod = l.prod⁻¹ := by
    have a1 : ∀ w ∈ l, w⁻¹ = w := fun w hw ↦ swap_inv_eq_self (hl w hw)|>.symm
    simpa [List.map_eq_map_iff.mpr a1, List.map_id] using l.prod_reverse_noncomm
  rw [← foldl_apply_eq_scanl_last l x, foldl_eq_reverse_prod l x, h_prod_reverse, h]
  simp

open Equiv SimpleGraph Subgroup in
lemma graph_connected [DecidableEq α] [Nonempty α] (E : Set (Equiv.Perm α))
    (hE : ∀ σ ∈ E, σ.IsSwap) (h_closure : Subgroup.closure E = ⊤)
    : (SimpleGraph.fromRel (λ x y => swap x y ∈ E)).Connected := by
  apply Connected.mk
  let G := SimpleGraph.fromRel (λ x y => swap x y ∈ E)
  -- Define the action of the subgroup generated by E on α
  let H := Subgroup.closure E
  have hH_top : H = ⊤ := h_closure
  intro x y
  have h_swap_in_H : swap x y ∈ H := by rw [hH_top]; apply mem_top
  -- Express swap x y as a product of elements from E
  have : ∃ l : List (Equiv.Perm α), (∀ τ ∈ l, τ ∈ E) ∧ l.prod = swap x y := by
    have ⟨l, h1, h2⟩ := Subgroup.exists_list_of_mem_closure h_swap_in_H
    use l
    refine ⟨?_, h2⟩
    intro τ a
    rcases (h1 _ a) with h | h
    · exact h
    · rwa [swap_inv_eq_self (hE _ h)] at h
  obtain ⟨l, hlE, hl_prod⟩ := this
  -- Build the sequence of vertices starting from x by applying the permutations in l
  let vertices := l.scanl (λ a τ => τ a) x
  have : vertices.length = l.length + 1 := l.length_scanl x
  have h_adj : ∀ i (hi : i < l.length), vertices[i] ≠ vertices[i+1] →
      G.Adj vertices[i] vertices[i+1] := by
    intro i hi hj
    refine (SimpleGraph.fromRel_adj _ _ _).mpr ⟨hj, ?_⟩
    left
    let τ := l[i]
    have hτE : τ ∈ E := hlE τ (l.get_mem i _)
    obtain ⟨a, b, _, hτ_eq⟩ := hE τ hτE
    have h_next : vertices[i+1] = τ vertices[i] := List.getElem_succ_scanl _
    rw [h_next, hτ_eq]
    by_cases h_case : vertices[i] = a
    · rw [h_case, swap_apply_left]
      exact Set.mem_of_eq_of_mem hτ_eq.symm hτE
    · by_cases h_case' : vertices[i] = b
      · rw [h_case', swap_apply_right, swap_comm]
        exact Set.mem_of_eq_of_mem hτ_eq.symm hτE
      · rw [hτ_eq] at h_next
        have := swap_apply_of_ne_of_ne h_case h_case'
        simp_all
  -- Construct the path from x to y using the sequence of vertices
  let rec build_walk (n : Nat) (hn : n ≤ l.length) : G.Walk vertices[n] vertices[l.length] :=
    if h_eq : n = l.length then by
      convert Walk.nil
      exact h_eq.symm
    else
      let tail := build_walk (n + 1) (by omega)
      if v_eq : vertices[n] = vertices[n+1] then
        v_eq ▸ tail
      else
        have edge : G.Adj vertices[n] vertices[n+1] := h_adj n (by omega) v_eq
        Walk.cons edge tail
  -- Build the walk starting from n = 0
  let walk := build_walk 0 l.length.zero_le
  have h_start : vertices[0] = x := List.getElem_scanl_zero
  have h_end : vertices[l.length] = y := graph_connected.aux1 (fun τ a ↦ hE τ (hlE τ a)) hl_prod
  exact ⟨h_start ▸ h_end ▸ walk⟩

/--
  **Lemma 1:** Let `E ⊆ Perm α` be a set of transpositions acting on a finite type `α`.
  Let `G` be the undirected graph on `α` with edge set `E`.
  Then `E` generates the symmetric group `Perm α` if and only if `G` is connected.
-/
theorem transpositions_generate_symm_group_iff_connected_graph
    {α : Type*} [DecidableEq α] [Finite α] [Nonempty α]
    (E : Set (Perm α))
    (hE : ∀ σ ∈ E, σ.IsSwap) :
    Subgroup.closure E = ⊤ ↔ (SimpleGraph.fromRel (λ x y => swap x y ∈ E)).Connected := by
  constructor
  · exact graph_connected E hE
  · intro hG_connected
    apply (Subgroup.eq_top_iff' _).mpr
    intro σ
    have swap_in_closure : ∀ a b : α, swap a b ∈ Subgroup.closure E := by
      intros a b
      have h_walk : (SimpleGraph.fromRel (λ x y => swap x y ∈ E)).Reachable a b := hG_connected a b
      obtain ⟨p⟩ := h_walk
      induction' p with _ x y z adj_edge _ IH
      · rw [swap_self]
        exact Subgroup.one_mem _
      ·
        by_cases h_eq : x = z
        · have : swap x z = Equiv.refl _ := swap_eq_refl_iff.mpr h_eq
          rw [this]
          exact (Subgroup.mul_mem_cancel_right (Subgroup.closure E) IH).mp IH
        have swap_xy_in_E : swap x y ∈ E := by
          have := (SimpleGraph.fromRel_adj _ _ _).mp adj_edge |>.2
          rcases this with h | h
          · exact h
          · rwa [swap_comm]
        have swap_xy_in_closure : swap x y ∈ Subgroup.closure E :=
          Subgroup.subset_closure swap_xy_in_E
        have swap_xz_eq : swap z x = (swap y z) * (swap x y) * (swap y z) := by
          symm
          apply Equiv.swap_mul_swap_mul_swap ?_ h_eq
          aesop
        have swap_xz_in_closure : swap x z ∈ Subgroup.closure E := by
          rw [swap_comm, swap_xz_eq]
          exact Subgroup.mul_mem _ (Subgroup.mul_mem _ IH swap_xy_in_closure) IH
        exact swap_xz_in_closure
    have : σ ∈ Subgroup.closure {τ : Perm α | τ.IsSwap} := by
      apply Equiv.Perm.swap_induction_on
      · exact Subgroup.one_mem _
      · intros τ a b hab hτ
        have h_swap : swap a b ∈ Subgroup.closure { τ : Perm α | τ.IsSwap } := by
          refine Subgroup.subset_closure ?_
          refine Set.mem_setOf.mpr ?_
          use a, b
        exact Subgroup.mul_mem _ h_swap hτ
    have : σ ∈ Subgroup.closure E := by
      apply Equiv.Perm.swap_induction_on
      · exact Subgroup.one_mem _
      · intros τ a b _ hτ
        have h_swap : swap a b ∈ Subgroup.closure E := swap_in_closure a b
        exact Subgroup.mul_mem _ h_swap hτ
    exact this
