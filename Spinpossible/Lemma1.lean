import Mathlib.Combinatorics.SimpleGraph.Path
import Mathlib.GroupTheory.Perm.Sign

-- HEAVILY inspired by Group.exists_list_of_mem_closure
theorem Subgroup.exists_list_of_mem_closure [Group M] {s : Set M} {a : M} (h : a ∈ Subgroup.closure s) :
    ∃ l : List M, (∀ x ∈ l, x ∈ s ∨ x⁻¹ ∈ s) ∧ l.prod = a := by
  refine Subgroup.closure_induction h
    (fun {x} hxs => ⟨[x], List.forall_mem_singleton.2 <| Or.inl hxs, one_mul _⟩)
    ⟨[], List.forall_mem_nil _, rfl⟩ ?_ ?_
  · intro a b ⟨La, HL1a, HL2a⟩ ⟨L, HL1, HL2⟩
    use La ++ L
    aesop
  · intro a ⟨L, HL1, HL2⟩
    use L.reverse.map Inv.inv
    constructor
    · intro w hw
      have : w⁻¹ ∈ L := by simp_all
      have := HL1 _ this
      aesop
    · simp [← congr($HL2⁻¹), List.prod_inv_reverse]

open Equiv

lemma scanl_last_eq_foldl_perm {α β : Type*} (l : List (Perm α)) (f : β → Perm α → β) (x : β) :
    (List.scanl f x l)[l.length]'(by simp [List.length_scanl]) = List.foldl f x l := by
  induction' l with head _ ih generalizing x
  · rfl
  · exact ih _

lemma foldl_perm_eq_prod_rev {α : Type*} (l : List (Perm α)) (x : α) :
  List.foldl (fun a τ ↦ τ a) x l = l.reverse.prod x := by
  induction' l generalizing x
  · rfl
  · simp_all [List.foldl]

lemma isSwap_inv_eq_self [DecidableEq α] {x : Perm α} (h : x.IsSwap) : x = x⁻¹ := by
  have ⟨_, _, _, hswap⟩ := h
  rw [hswap, swap_inv]

lemma isSwap_swap_ne [DecidableEq α] {x y : α} (h : (swap x y).IsSwap) : x ≠ y := by
  by_contra h_eq
  rw [h_eq, swap_self] at h
  obtain ⟨_, _, h1, hswap⟩ := h
  exact h1 (swap_eq_refl_iff.mp hswap.symm)

lemma graph_connected.aux1 [DecidableEq α]
  {l : List (Perm α)} (hl : ∀ τ ∈ l, τ.IsSwap) (h : l.prod = swap x y) :
  (List.scanl (fun a τ ↦ τ a) x l)[l.length]'(by simp [List.length_scanl]) = y := by
  have h_prod_reverse : l.reverse.prod = l.prod⁻¹ := by
    have a1 : ∀ w ∈ l, w⁻¹ = w := fun w hw ↦ isSwap_inv_eq_self (hl w hw)|>.symm
    simpa [List.map_eq_map_iff.mpr a1, List.map_id] using l.prod_reverse_noncomm
  rw [scanl_last_eq_foldl_perm, foldl_perm_eq_prod_rev, h_prod_reverse, h]
  simp

lemma graph_connected [DecidableEq α] [Nonempty α] (E : Set (Perm α))
    (hE : ∀ σ ∈ E, σ.IsSwap) (h_closure : Subgroup.closure E = ⊤) :
    (SimpleGraph.fromRel (fun x y => swap x y ∈ E)).Connected := by
  apply SimpleGraph.Connected.mk
  set G := SimpleGraph.fromRel (fun x y => swap x y ∈ E)
  -- Define the action of the subgroup generated by E on α
  let H := Subgroup.closure E
  have hH_top : H = ⊤ := h_closure
  intro x y
  have h_swap_in_H : swap x y ∈ H := by rw [hH_top]; exact Subgroup.mem_top _
  -- Express swap x y as a product of elements from E
  have ⟨l, hlE, hl_prod⟩ : ∃ l : List (Perm α), (∀ τ ∈ l, τ ∈ E) ∧ l.prod = swap x y := by
    have ⟨l, h1, h2⟩ := Subgroup.exists_list_of_mem_closure h_swap_in_H
    use l
    refine ⟨?_, h2⟩
    intro τ a
    rcases (h1 _ a) with h | h
    · exact h
    · rwa [isSwap_inv_eq_self (hE _ h)] at h
  -- Build the sequence of vertices starting from x by applying the permutations in l
  let vertices := l.scanl (fun a τ => τ a) x
  have : vertices.length = l.length + 1 := l.length_scanl x
  have h_adj : ∀ i (hi : i < l.length), vertices[i] ≠ vertices[i+1] →
      G.Adj vertices[i] vertices[i+1] := by
    intro i hi hj
    refine (SimpleGraph.fromRel_adj _ _ _).mpr ⟨hj, ?_⟩
    left
    let τ := l[i]
    have hτE : τ ∈ E := hlE τ (l.get_mem i _)
    obtain ⟨a, b, _, hτ_eq⟩ := hE τ hτE
    have h_next : vertices[i+1] = τ vertices[i] := List.getElem_succ_scanl _
    rw [h_next, hτ_eq]
    by_cases h_case : vertices[i] = a
    · rw [h_case, swap_apply_left]
      exact Set.mem_of_eq_of_mem hτ_eq.symm hτE
    · by_cases h_case' : vertices[i] = b
      · rw [h_case', swap_apply_right, swap_comm]
        exact Set.mem_of_eq_of_mem hτ_eq.symm hτE
      · rw [hτ_eq] at h_next
        have := swap_apply_of_ne_of_ne h_case h_case'
        simp_all
  -- Construct the path from x to y using the sequence of vertices
  let rec build_walk (n : Nat) (hn : n ≤ l.length) : G.Walk vertices[n] vertices[l.length] :=
    if h_eq : n = l.length then by
      convert SimpleGraph.Walk.nil
      exact h_eq.symm
    else
      let tail := build_walk (n + 1) (by omega)
      if v_eq : vertices[n] = vertices[n+1] then
        v_eq ▸ tail
      else
        have edge : G.Adj vertices[n] vertices[n+1] := h_adj n (by omega) v_eq
        SimpleGraph.Walk.cons edge tail
  -- Build the walk starting from n = 0
  let walk := build_walk 0 l.length.zero_le
  have h_start : vertices[0] = x := List.getElem_scanl_zero
  have h_end : vertices[l.length] = y := graph_connected.aux1 (fun τ a ↦ hE τ (hlE τ a)) hl_prod
  exact ⟨h_start ▸ h_end ▸ walk⟩

/--
  **Lemma 1**: Let `E ⊆ Perm α` be a set of transpositions acting on a finite type `α`.
  Let `G` be the undirected graph on `α` with edge set `E`.
  Then `E` generates the symmetric group `Perm α` if and only if `G` is connected.
-/
theorem transpositions_generate_symm_group_iff_connected_graph
    {α : Type*} [DecidableEq α] [Finite α] [Nonempty α]
    (E : Set (Perm α))
    (hE : ∀ σ ∈ E, σ.IsSwap) :
    Subgroup.closure E = ⊤ ↔ (SimpleGraph.fromRel (fun x y => swap x y ∈ E)).Connected := by
  refine ⟨graph_connected E hE, ?_⟩
  intro hG_connected
  apply (Subgroup.eq_top_iff' _).mpr
  intro σ
  induction' σ using Perm.swap_induction_on with τ a b hab hτ
  · exact Subgroup.one_mem _
  · clear hab
    refine Subgroup.mul_mem _ ?_ hτ
    have ⟨p⟩ : (SimpleGraph.fromRel _).Reachable a b := hG_connected a b
    induction' p with _ x y z adj_edge _ ih
    · rw [swap_self]
      exact Subgroup.one_mem _
    · by_cases h_eq : x = z
      · rw [swap_eq_refl_iff.mpr h_eq]
        exact Subgroup.one_mem _
      have swap_xy_in_E : swap x y ∈ E := by
        have := (SimpleGraph.fromRel_adj _ _ _).mp adj_edge
        rcases this.2 with h | h
        · exact h
        · rwa [swap_comm]
      have swap_xz_eq : (swap y z) * (swap x y) * (swap y z) = swap z x :=
        swap_mul_swap_mul_swap (isSwap_swap_ne (hE _ swap_xy_in_E)) h_eq
      rw [swap_comm, ← swap_xz_eq,
        Subgroup.mul_mem_cancel_right _ ih, Subgroup.mul_mem_cancel_left _ ih]
      exact Subgroup.subset_closure swap_xy_in_E
